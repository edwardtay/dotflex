/**
 * Smart Contract Integration Utilities for VRF Lottery
 * 
 * Integration with ink! smart contract deployed on Polkadot testnet
 */

import { ApiPromise } from '@polkadot/api'
import type { InjectedAccountWithMeta } from '@polkadot/extension-inject/types'
import { ContractPromise, Abi } from '@polkadot/api-contract'

// Contract address - Set this after deployment
const CONTRACT_ADDRESS = import.meta.env.VITE_VRF_LOTTERY_CONTRACT_ADDRESS || ''

// Contract ABI/Metadata - Load from metadata JSON file
// The metadata should be generated by cargo-contract and placed in public/contracts/
let contractAbi: Abi | null = null
let contractInstance: ContractPromise | null = null

/**
 * Load contract ABI from metadata file
 */
async function loadContractAbi(): Promise<Abi | null> {
  if (contractAbi) {
    return contractAbi
  }

  try {
    // Try to load metadata from public directory
    // In production, this should be fetched from IPFS or included in build
    const metadataResponse = await fetch('/contracts/vrf_lottery.json')
    
    if (metadataResponse.ok) {
      const metadata = await metadataResponse.json()
      contractAbi = new Abi(metadata)
      return contractAbi
    } else {
      console.warn('[Contract] Metadata file not found. Contract queries may not work correctly.')
      // Return a minimal ABI structure for basic operations
      return null
    }
  } catch (error) {
    console.warn('[Contract] Failed to load contract metadata:', error)
    return null
  }
}

/**
 * Initialize contract instance
 */
export async function initContract(api: ApiPromise): Promise<ContractPromise | null> {
  if (!CONTRACT_ADDRESS) {
    console.warn('[Contract] Contract address not configured. Set VITE_VRF_LOTTERY_CONTRACT_ADDRESS')
    return null
  }

  if (contractInstance) {
    return contractInstance
  }

  try {
    const abi = await loadContractAbi()
    
    // Create contract instance
    // If ABI is not available, we can still create the instance but queries may fail
    const contract = abi 
      ? new ContractPromise(api, abi, CONTRACT_ADDRESS)
      : new ContractPromise(api, {} as any, CONTRACT_ADDRESS)

    contractInstance = contract
    return contract
  } catch (error) {
    console.error('[Contract] Failed to initialize contract:', error)
    return null
  }
}

/**
 * Participate in lottery
 */
export async function participateInLottery(
  api: ApiPromise,
  contract: ContractPromise,
  account: InjectedAccountWithMeta,
  participationFee: bigint
): Promise<{ success: boolean; ticketNumber?: number; error?: string }> {
  try {
    // Get signer from Polkadot.js extension
    const injector = await (window as any).injectedWeb3?.['polkadot-js']?.enable()
    if (!injector) {
      throw new Error('Polkadot.js extension not available')
    }

    // Call participate function (payable)
    const tx = contract.tx.participate(
      { value: participationFee, gasLimit: -1 },
      {}
    )

    await new Promise<void>((resolve, reject) => {
      tx.signAndSend(account.address, { signer: injector.signer }, ({ status, dispatchError }) => {
        if (dispatchError) {
          reject(new Error(dispatchError.toString()))
        } else if (status.isInBlock || status.isFinalized) {
          resolve()
        }
      }).catch(reject)
    })

    // Wait a bit for block confirmation, then query ticket number
    await new Promise(resolve => setTimeout(resolve, 2000))
    const result = await queryParticipant(api, contract, account.address)
    
    return {
      success: true,
      ticketNumber: result?.ticketNumber || undefined
    }
  } catch (error: any) {
    console.error('[Contract] Failed to participate:', error)
    return {
      success: false,
      error: error.message || 'Participation failed'
    }
  }
}

/**
 * Draw lottery using VRF
 */
export async function drawLottery(
  api: ApiPromise,
  contract: ContractPromise,
  account: InjectedAccountWithMeta
): Promise<{ success: boolean; won?: boolean; rewardAmount?: string; error?: string }> {
  try {
    // Get signer from Polkadot.js extension
    const injector = await (window as any).injectedWeb3?.['polkadot-js']?.enable()
    if (!injector) {
      throw new Error('Polkadot.js extension not available')
    }

    // Call draw function
    const tx = contract.tx.draw({ gasLimit: -1 }, {})

    await new Promise<void>((resolve, reject) => {
      tx.signAndSend(account.address, { signer: injector.signer }, ({ status, dispatchError }) => {
        if (dispatchError) {
          reject(new Error(dispatchError.toString()))
        } else if (status.isInBlock || status.isFinalized) {
          resolve()
        }
      }).catch(reject)
    })

    // Wait for block confirmation, then query result
    await new Promise(resolve => setTimeout(resolve, 2000))
    const result = await queryParticipant(api, contract, account.address)
    
    return {
      success: true,
      won: result?.won || false,
      rewardAmount: result?.rewardAmount ? formatBalance(result.rewardAmount) : undefined
    }
  } catch (error: any) {
    console.error('[Contract] Failed to draw:', error)
    return {
      success: false,
      error: error.message || 'Draw failed'
    }
  }
}

/**
 * Claim reward
 */
export async function claimReward(
  api: ApiPromise,
  contract: ContractPromise,
  account: InjectedAccountWithMeta
): Promise<{ success: boolean; amount?: string; error?: string }> {
  try {
    // Get signer from Polkadot.js extension
    const injector = await (window as any).injectedWeb3?.['polkadot-js']?.enable()
    if (!injector) {
      throw new Error('Polkadot.js extension not available')
    }

    // Call claim_reward function
    const tx = contract.tx.claimReward({ gasLimit: -1 }, {})
    
    let claimedAmount: string | undefined
    
    await new Promise<void>((resolve, reject) => {
      tx.signAndSend(account.address, { signer: injector.signer }, ({ status, dispatchError }) => {
        if (dispatchError) {
          reject(new Error(dispatchError.toString()))
        } else if (status.isInBlock || status.isFinalized) {
          // Query the claimed amount
          queryParticipant(api, contract, account.address).then(participant => {
            // Amount is cleared after claim, so we can't query it
            // But we can return success
            resolve()
          }).catch(reject)
        }
      }).catch(reject)
    })

    return {
      success: true,
      amount: claimedAmount
    }
  } catch (error: any) {
    console.error('[Contract] Failed to claim:', error)
    return {
      success: false,
      error: error.message || 'Claim failed'
    }
  }
}

/**
 * Query participant information
 */
export async function queryParticipant(
  api: ApiPromise,
  contract: ContractPromise,
  address: string
): Promise<{
  ticketNumber: number
  participatedAt: number
  hasDrawn: boolean
  won: boolean
  rewardAmount: bigint
} | null> {
  try {
    // Query get_participant function
    // Note: Method name should match contract (snake_case in Rust becomes camelCase in JS)
    const result = await contract.query.getParticipant(
      address,
      { gasLimit: -1 },
      address
    )

    if (result.result.isOk && result.output) {
      const data = result.output.toHuman() as any
      // Handle both snake_case and camelCase field names
      const participant = data.Ok || data
      return {
        ticketNumber: parseInt(participant?.ticketNumber || participant?.ticket_number || '0'),
        participatedAt: parseInt(participant?.participatedAt || participant?.participated_at || '0'),
        hasDrawn: participant?.hasDrawn !== undefined ? participant.hasDrawn : (participant?.has_drawn || false),
        won: participant?.won || false,
        rewardAmount: BigInt(
          (participant?.rewardAmount || participant?.reward_amount || '0')
            .toString()
            .replace(/,/g, '')
            .replace(/[^0-9]/g, '') || '0'
        )
      }
    }

    return null
  } catch (error) {
    console.error('[Contract] Failed to query participant:', error)
    return null
  }
}

/**
 * Query lottery configuration
 */
export async function queryConfig(
  api: ApiPromise,
  contract: ContractPromise
): Promise<{
  participationFee: bigint
  minParticipants: number
  winProbabilityBps: number
  maxReward: bigint
} | null> {
  try {
    const result = await contract.query.getConfig(
      contract.address,
      { gasLimit: -1 }
    )

    if (result.result.isOk && result.output) {
      const data = result.output.toHuman() as any
      const config = data.Ok || data
      return {
        participationFee: BigInt(
          (config?.participationFee || config?.participation_fee || '0')
            .toString()
            .replace(/,/g, '')
            .replace(/[^0-9]/g, '') || '0'
        ),
        minParticipants: parseInt(config?.minParticipants || config?.min_participants || '0'),
        winProbabilityBps: parseInt(config?.winProbabilityBps || config?.win_probability_bps || '0'),
        maxReward: BigInt(
          (config?.maxReward || config?.max_reward || '0')
            .toString()
            .replace(/,/g, '')
            .replace(/[^0-9]/g, '') || '0'
        )
      }
    }

    return null
  } catch (error) {
    console.error('[Contract] Failed to query config:', error)
    return null
  }
}

/**
 * Query contract balance
 */
export async function queryBalance(
  api: ApiPromise,
  contract: ContractPromise
): Promise<bigint | null> {
  try {
    const result = await contract.query.getBalance(
      contract.address,
      { gasLimit: -1 }
    )

    if (result.result.isOk && result.output) {
      const balance = result.output.toHuman() as any
      return BigInt(balance?.replace(/,/g, '') || '0')
    }

    return null
  } catch (error) {
    console.error('[Contract] Failed to query balance:', error)
    return null
  }
}

/**
 * Format balance for display
 */
export function formatBalance(balance: bigint, decimals: number = 10): string {
  const divisor = BigInt(10 ** decimals)
  const whole = balance / divisor
  const fractional = balance % divisor
  const fractionalStr = fractional.toString().padStart(decimals, '0')
  const trimmed = fractionalStr.replace(/0+$/, '')
  
  return trimmed ? `${whole}.${trimmed}` : whole.toString()
}

